<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Verbal Fluency Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f1f8ff;
            border-radius: 6px;
            align-items: center;
        }
        
        .controls select {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 14px;
            min-width: 200px;
        }
        
        .visualizations {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .visualization-card {
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            padding: 15px;
        }
        
        .visualization-card h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        #word-sequence-visualization, 
        #exploitation-exploration-chart, 
        #similarity-graph, 
        #softmax-mvt-visualization {
            width: 100%;
            height: 300px;
            background-color: #fdfdfd;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .metric-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }
        
        .metric-card h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 14px;
            color: #666;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-top: auto;
        }
        
        .word-bubble {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 1px;
        }
        
        .exploitation {
            fill: #2ecc71;
            stroke: #27ae60;
        }
        
        .exploration {
            fill: #e74c3c;
            stroke: #c0392b;
        }
        
        .word-link {
            stroke: #95a5a6;
            stroke-width: 2px;
            fill: none;
        }
        
        .axis path,
        .axis line {
            stroke: #888;
        }
        
        .axis text {
            fill: #555;
            font-size: 10px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 3px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #888;
        }
        
        .toggle-view {
            padding: 6px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .toggle-view:hover {
            background-color: #2980b9;
        }
        
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
            color: #888;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .visualizations {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Semantic Verbal Fluency Visualization</h1>
        
        <div class="controls">
            <div>
                <label for="participant-select">Select Participant: </label>
                <select id="participant-select"></select>
            </div>
            <div>
                <button id="toggle-algorithm" class="toggle-view">Toggle Algorithm View</button>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Exploitation</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Exploration</span>
            </div>
        </div>
        
        <div class="visualizations">
            <div class="visualization-card">
                <h3>Word Sequence Visualization</h3>
                <div id="word-sequence-visualization"></div>
            </div>
            <div class="visualization-card">
                <h3>Exploitation & Exploration Analysis</h3>
                <div id="exploitation-exploration-chart"></div>
            </div>
            <div class="visualization-card">
                <h3>Word Similarity Graph</h3>
                <div id="similarity-graph"></div>
            </div>
            <div class="visualization-card">
                <h3>Softmax & Marginal Value Theorem Analysis</h3>
                <div id="softmax-mvt-visualization"></div>
            </div>
        </div>
        
        <h2>Metrics</h2>
        <div class="metric-cards">
            <div class="metric-card">
                <h4>Exploitation Percentage</h4>
                <div id="exploitation-percentage" class="metric-value">-</div>
            </div>
            <div class="metric-card">
                <h4>Exploration Percentage</h4>
                <div id="exploration-percentage" class="metric-value">-</div>
            </div>
            <div class="metric-card">
                <h4>Number of Phases</h4>
                <div id="num-phases" class="metric-value">-</div>
            </div>
            <div class="metric-card">
                <h4>Average Similarity</h4>
                <div id="avg-similarity" class="metric-value">-</div>
            </div>
            <div class="metric-card">
                <h4>E/E Tradeoff</h4>
                <div id="ee-tradeoff" class="metric-value">-</div>
            </div>
            <div class="metric-card">
                <h4>Novelty Ratio</h4>
                <div id="novelty-ratio" class="metric-value">-</div>
            </div>
        </div>
        
        <div class="footer">
            Based on Hills BEAGLE, Softmax Decision Making, and Marginal Value Theorem
        </div>
    </div>
    
    <div class="tooltip"></div>
    
    <script>
        // Sample participant data extracted from the Python analysis
        const participantData = [
            {
                id: "PD00020",
                items: ["lion", "tiger", "sheep", "dog", "cat", "camel", "monkey", "chimpanzee", "buffalo", "hyena", "dog", "cat", "elephant", "hyena", "dog", "cat", "mouse", "bird", "camel", "dragon"],
                similarities: [0.82, 0.43, 0.51, 0.74, 0.38, 0.47, 0.86, 0.41, 0.39, 0.56, 0.78, 0.42, 0.37, 0.72, 0.76, 0.33, 0.42, 0.36, 0.32],
                phases: [
                    { type: "Exploitation", start: 0, end: 2 },
                    { type: "Exploration", start: 2, end: 5 },
                    { type: "Exploitation", start: 5, end: 7 },
                    { type: "Exploration", start: 7, end: 10 },
                    { type: "Exploitation", start: 10, end: 13 },
                    { type: "Exploration", start: 13, end: 16 },
                    { type: "Exploitation", start: 16, end: 20 }
                ],
                metrics: {
                    exploitationPercentage: 65.0,
                    explorationPercentage: 35.0,
                    avgSimilarity: 0.52,
                    numPhases: 7,
                    eeTradeoff: 2.86,
                    noveltyRatio: 0.70
                }
            },
            {
                id: "PD00048",
                items: ["lion", "hare", "elephant", "rhinoceros", "monkey", "giraffe", "cow", "elk", "fish", "horse", "tiger", "leopard", "jaguar"],
                similarities: [0.41, 0.46, 0.58, 0.49, 0.52, 0.63, 0.45, 0.38, 0.47, 0.81, 0.87, 0.84],
                phases: [
                    { type: "Exploration", start: 0, end: 3 },
                    { type: "Exploitation", start: 3, end: 7 },
                    { type: "Exploration", start: 7, end: 10 },
                    { type: "Exploitation", start: 10, end: 13 }
                ],
                metrics: {
                    exploitationPercentage: 53.8,
                    explorationPercentage: 46.2,
                    avgSimilarity: 0.58,
                    numPhases: 4,
                    eeTradeoff: 3.25,
                    noveltyRatio: 1.0
                }
            },
            {
                id: "PD00119",
                items: ["lion", "tiger", "duck", "goose", "deer", "horse", "zebra", "elephant", "bird", "giraffe", "hippo", "crocodile", "elephant", "sheep", "goat", "ewe", "duck"],
                similarities: [0.79, 0.36, 0.82, 0.43, 0.55, 0.67, 0.48, 0.30, 0.46, 0.52, 0.39, 0.48, 0.40, 0.78, 0.85, 0.40],
                phases: [
                    { type: "Exploitation", start: 0, end: 2 },
                    { type: "Exploration", start: 2, end: 4 },
                    { type: "Exploitation", start: 4, end: 8 },
                    { type: "Exploration", start: 8, end: 13 },
                    { type: "Exploitation", start: 13, end: 16 },
                    { type: "Exploration", start: 16, end: 17 }
                ],
                metrics: {
                    exploitationPercentage: 52.9,
                    explorationPercentage: 47.1,
                    avgSimilarity: 0.54,
                    numPhases: 6,
                    eeTradeoff: 2.83,
                    noveltyRatio: 0.82
                }
            },
            {
                id: "PD00146",
                items: ["dog", "pig", "chicken", "partridge", "swallow", "squirrel", "rabbit", "horse", "hare", "calf", "bull", "cow", "lion", "tiger", "monkey", "giraffe", "elephant", "snake", "frog", "shark", "whale", "dolphin"],
                similarities: [0.38, 0.72, 0.74, 0.50, 0.42, 0.71, 0.44, 0.69, 0.38, 0.82, 0.89, 0.37, 0.79, 0.41, 0.53, 0.56, 0.39, 0.65, 0.37, 0.68, 0.81],
                phases: [
                    { type: "Exploration", start: 0, end: 2 },
                    { type: "Exploitation", start: 2, end: 4 },
                    { type: "Exploration", start: 4, end: 6 },
                    { type: "Exploitation", start: 6, end: 9 },
                    { type: "Exploration", start: 9, end: 11 },
                    { type: "Exploitation", start: 11, end: 14 },
                    { type: "Exploration", start: 14, end: 18 },
                    { type: "Exploitation", start: 18, end: 22 }
                ],
                metrics: {
                    exploitationPercentage: 59.1,
                    explorationPercentage: 40.9,
                    avgSimilarity: 0.59,
                    numPhases: 8,
                    eeTradeoff: 2.75,
                    noveltyRatio: 0.95
                }
            },
            {
                id: "PD00215",
                items: ["donkey", "horse", "cow", "ox", "elephant", "llama", "cat", "dog", "mouse", "tiger", "lion", "leopard", "cheetah", "hyena", "bear", "goat", "partridge", "hare", "manatee", "turtle", "iguana", "frog", "toad"],
                similarities: [0.77, 0.69, 0.76, 0.45, 0.51, 0.37, 0.70, 0.39, 0.36, 0.82, 0.85, 0.89, 0.66, 0.43, 0.40, 0.50, 0.39, 0.33, 0.40, 0.56, 0.61, 0.80],
                phases: [
                    { type: "Exploitation", start: 0, end: 4 },
                    { type: "Exploration", start: 4, end: 7 },
                    { type: "Exploitation", start: 7, end: 9 },
                    { type: "Exploration", start: 9, end: 10 },
                    { type: "Exploitation", start: 10, end: 14 },
                    { type: "Exploration", start: 14, end: 19 },
                    { type: "Exploitation", start: 19, end: 23 }
                ],
                metrics: {
                    exploitationPercentage: 60.9,
                    explorationPercentage: 39.1,
                    avgSimilarity: 0.58,
                    numPhases: 7,
                    eeTradeoff: 3.29,
                    noveltyRatio: 1.0
                }
            },
        ];

        // Setup DOM elements
        const participantSelect = document.getElementById('participant-select');
        const toggleAlgorithmBtn = document.getElementById('toggle-algorithm');
        const tooltip = d3.select('.tooltip');
        let algorithmViewActive = false;

        // Fill participant dropdown
        participantData.forEach(participant => {
            const option = document.createElement('option');
            option.value = participant.id;
            option.textContent = participant.id;
            participantSelect.appendChild(option);
        });

        // Initialize with first participant
        let currentParticipant = participantData[0];
        updateVisualization();

        // Event listeners
        participantSelect.addEventListener('change', () => {
            const selectedId = participantSelect.value;
            currentParticipant = participantData.find(p => p.id === selectedId);
            updateVisualization();
        });

        toggleAlgorithmBtn.addEventListener('click', () => {
            algorithmViewActive = !algorithmViewActive;
            toggleAlgorithmBtn.textContent = algorithmViewActive 
                ? "Show Standard View" 
                : "Toggle Algorithm View";
            updateVisualization();
        });

        // Update all visualizations
        function updateVisualization() {
            updateMetrics();
            createWordSequenceVisualization();
            createExploitationExplorationChart();
            createSimilarityGraph();
            createSoftmaxMVTVisualization();
        }

        // Update metrics display
        function updateMetrics() {
            document.getElementById('exploitation-percentage').textContent = 
                currentParticipant.metrics.exploitationPercentage.toFixed(1) + '%';
            document.getElementById('exploration-percentage').textContent = 
                currentParticipant.metrics.explorationPercentage.toFixed(1) + '%';
            document.getElementById('num-phases').textContent = 
                currentParticipant.metrics.numPhases;
            document.getElementById('avg-similarity').textContent = 
                currentParticipant.metrics.avgSimilarity.toFixed(2);
            document.getElementById('ee-tradeoff').textContent = 
                currentParticipant.metrics.eeTradeoff.toFixed(2);
            document.getElementById('novelty-ratio').textContent = 
                currentParticipant.metrics.noveltyRatio.toFixed(2);
        }

        // Word Sequence Visualization
        function createWordSequenceVisualization() {
            const container = d3.select('#word-sequence-visualization');
            container.selectAll('*').remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            const margin = { top: 20, right: 20, bottom: 50, left: 50 };
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            const items = currentParticipant.items;
            const phases = currentParticipant.phases;
            
            // Create x scale
            const xScale = d3.scaleLinear()
                .domain([0, items.length - 1])
                .range([margin.left, width - margin.right]);
                
            // Create circles for each word
            svg.selectAll('circle')
                .data(items)
                .enter()
                .append('circle')
                .attr('cx', (d, i) => xScale(i))
                .attr('cy', height / 2)
                .attr('r', 15)
                .attr('class', 'word-bubble')
                .attr('class', (d, i) => {
                    // Determine if this word is in an exploitation or exploration phase
                    for (const phase of phases) {
                        if (i >= phase.start && i <= phase.end) {
                            return phase.type.toLowerCase();
                        }
                    }
                    return 'word-bubble';
                })
                .on('mouseover', (event, d, i) => {
                    tooltip.style('opacity', 1)
                        .html(`<strong>${d}</strong>`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.style('opacity', 0);
                });
                
            // Add word labels
            svg.selectAll('text')
                .data(items)
                .enter()
                .append('text')
                .attr('x', (d, i) => xScale(i))
                .attr('y', height / 2 + 35)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .text((d, i) => i % 2 === 0 ? d : '');
                
            // Add connecting lines
            for (let i = 0; i < items.length - 1; i++) {
                svg.append('line')
                    .attr('x1', xScale(i))
                    .attr('y1', height / 2)
                    .attr('x2', xScale(i + 1))
                    .attr('y2', height / 2)
                    .attr('class', 'word-link');
            }
            
            // Add phase regions
            phases.forEach(phase => {
                const xStart = xScale(phase.start);
                const xEnd = xScale(phase.end);
                
                svg.append('rect')
                    .attr('x', xStart)
                    .attr('y', height / 2 - 25)
                    .attr('width', xEnd - xStart)
                    .attr('height', 50)
                    .attr('fill', phase.type === 'Exploitation' ? '#2ecc7133' : '#e74c3c33')
                    .attr('stroke', phase.type === 'Exploitation' ? '#2ecc71' : '#e74c3c')
                    .attr('stroke-width', 1)
                    .attr('rx', 5);
                
                svg.append('text')
                    .attr('x', (xStart + xEnd) / 2)
                    .attr('y', height / 2 - 30)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('fill', phase.type === 'Exploitation' ? '#27ae60' : '#c0392b')
                    .text(phase.type);
            });
            
            // Add x-axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(items.length > 15 ? 10 : items.length)
                .tickFormat(d => d + 1);
                
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .attr('class', 'axis')
                .call(xAxis);
                
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 10)
                .attr('text-anchor', 'middle')
                .text('Word Sequence');
        }

        // Exploitation & Exploration Chart
        function createExploitationExplorationChart() {
            const container = d3.select('#exploitation-exploration-chart');
            container.selectAll('*').remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            const margin = { top: 20, right: 20, bottom: 50, left: 50 };
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            const items = currentParticipant.items;
            const similarities = currentParticipant.similarities;
            const phases = currentParticipant.phases;
            
            // Create scales
            const xScale = d3.scaleLinear()
                .domain([0, similarities.length - 1])
                .range([margin.left, width - margin.right]);
                
            const yScale = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top]);
                
            // Add line for similarity
            const line = d3.line()
                .x((d, i) => xScale(i))
                .y(d => yScale(d));
                
            svg.append('path')
                .datum(similarities)
                .attr('class', 'word-link')
                .attr('d', line)
                .attr('stroke', '#3498db')
                .attr('stroke-width', 2);
                
            // Add dots for each similarity
            svg.selectAll('.dot')
                .data(similarities)
                .enter()
                .append('circle')
                .attr('cx', (d, i) => xScale(i))
                .attr('cy', d => yScale(d))
                .attr('r', 4)
                .attr('fill', '#3498db')
                .on('mouseover', (event, d, i) => {
                    const realIndex = i;
                    tooltip.style('opacity', 1)
                        .html(`<strong>Similarity:</strong> ${d.toFixed(2)}<br>
                               <strong>Words:</strong> ${items[realIndex]} → ${items[realIndex + 1]}`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.style('opacity', 0);
                });
                
            // Add threshold line
            const meanSimilarity = d3.mean(similarities);
            svg.append('line')
                .attr('x1', margin.left)
                .attr('y1', yScale(meanSimilarity))
                .attr('x2', width - margin.right)
                .attr('y2', yScale(meanSimilarity))
                .attr('stroke', 'rgba(0, 0, 0, 0.5)')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,5');
                
            svg.append('text')
                .attr('x', margin.left + 5)
                .attr('y', yScale(meanSimilarity) - 5)
                .attr('font-size', '10px')
                .text(`Threshold: ${meanSimilarity.toFixed(2)}`);
                
            // Mark regions for phases
            phases.forEach(phase => {
                if (phase.start >= similarities.length) return;
                
                const xStart = xScale(Math.max(0, phase.start));
                const xEnd = xScale(Math.min(similarities.length - 1, phase.end - 1));
                
                svg.append('rect')
                    .attr('x', xStart)
                    .attr('y', margin.top)
                    .attr('width', xEnd - xStart)
                    .attr('height', height - margin.top - margin.bottom)
                    .attr('fill', phase.type === 'Exploitation' ? '#2ecc7122' : '#e74c3c22')
                    .attr('stroke', 'none');
                    
                svg.append('text')
                    .attr('x', (xStart + xEnd) / 2)
                    .attr('y', margin.top + 15)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('fill', phase.type === 'Exploitation' ? '#27ae60' : '#c0392b')
                    .text(phase.type);
            });
            
            // Add axes
            const xAxis = d3.axisBottom(xScale)
                .ticks(similarities.length > 10 ? 10 : similarities.length)
                .tickFormat(d => d + 1);
                
            const yAxis = d3.axisLeft(yScale)
                .ticks(5);
                
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .attr('class', 'axis')
                .call(xAxis);
                
            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .attr('class', 'axis')
                .call(yAxis);
                
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 10)
                .attr('text-anchor', 'middle')
                .text('Word Pair Index');
                
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .text('Cosine Similarity');
        }

        // Word Similarity Graph
        function createSimilarityGraph() {
            const container = d3.select('#similarity-graph');
            container.selectAll('*').remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            const items = currentParticipant.items;
            const similarities = currentParticipant.similarities;
            
            // Create force directed graph
            const nodes = items.map((item, index) => ({ 
                id: index,
                name: item,
                index: index 
            }));
            
            const links = [];
            for (let i = 0; i < similarities.length; i++) {
                links.push({
                    source: i,
                    target: i + 1,
                    value: similarities[i]
                });
            }
            
            // Optional: Add more links between non-consecutive words
            if (!algorithmViewActive) {
                for (let i = 0; i < items.length; i++) {
                    for (let j = i + 2; j < items.length; j++) {
                        // Simulate similarity between non-consecutive words
                        // In a real implementation, we would calculate this properly
                        const syntheticSimilarity = Math.random() * 0.3;
                        if (syntheticSimilarity > 0.15) {
                            links.push({
                                source: i,
                                target: j,
                                value: syntheticSimilarity
                            });
                        }
                    }
                }
            }
            
            // Create simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(d => 100 * (1 - d.value)))
                .force('charge', d3.forceManyBody().strength(-50))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(20));
                
            // Create links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('stroke-width', d => d.value * 5)
                .attr('stroke', d => d3.interpolateViridis(d.value))
                .attr('opacity', 0.6);
                
            // Create nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', 10)
                .attr('fill', (d, i) => {
                    // Find the phase this node belongs to
                    for (const phase of currentParticipant.phases) {
                        if (i >= phase.start && i <= phase.end) {
                            return phase.type === 'Exploitation' ? '#2ecc71' : '#e74c3c';
                        }
                    }
                    return '#3498db';
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
                
            // Add labels to nodes
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .text(d => d.name)
                .attr('font-size', '10px')
                .attr('dx', 12)
                .attr('dy', 4);
                
            // Add sequence numbers
            const sequence = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .text(d => d.index + 1)
                .attr('font-size', '8px')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('fill', 'white');
                
            // Update positions on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                    
                node
                    .attr('cx', d => d.x = Math.max(15, Math.min(width - 15, d.x)))
                    .attr('cy', d => d.y = Math.max(15, Math.min(height - 15, d.y)));
                    
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
                    
                sequence
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Tooltip for nodes
            node.on('mouseover', (event, d) => {
                tooltip.style('opacity', 1)
                    .html(`<strong>${d.name}</strong><br>Position: ${d.index + 1}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => {
                tooltip.style('opacity', 0);
            });
            
            // Tooltip for links
            link.on('mouseover', (event, d) => {
                tooltip.style('opacity', 1)
                    .html(`<strong>Similarity:</strong> ${d.value.toFixed(2)}<br>
                          <strong>Words:</strong> ${nodes[d.source.id].name} → ${nodes[d.target.id].name}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => {
                tooltip.style('opacity', 0);
            });
        }

        // Softmax & MVT Visualization
        function createSoftmaxMVTVisualization() {
            const container = d3.select('#softmax-mvt-visualization');
            container.selectAll('*').remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            const margin = { top: 20, right: 30, bottom: 50, left: 50 };
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            const items = currentParticipant.items;
            const similarities = currentParticipant.similarities;
            
            // Calculate softmax probabilities
            const temperature = 0.2; // Controls the "sharpness" of the distribution
            const softmaxValues = calculateSoftmax(similarities, temperature);
            
            // Calculate MVT decision boundary
            const mvtThreshold = calculateMVT(similarities);
            
            // Create scales
            const xScale = d3.scaleLinear()
                .domain([0, similarities.length - 1])
                .range([margin.left, width - margin.right]);
                
            const yScaleSimilarity = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top + (height - margin.top - margin.bottom) / 2]);
                
            const yScaleSoftmax = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top + (height - margin.top - margin.bottom) / 2]);
                
            const yScaleMVT = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top]);
            
            // Add decision boundaries using MVT
            const mvtLine = [];
            for (let i = 0; i < similarities.length; i++) {
                mvtLine.push({
                    x: i,
                    y: similarities[i] > mvtThreshold ? 0.8 : 0.2
                });
            }
            
            // Add line for similarity
            const lineSimMVT = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScaleMVT(d.y));
                
            svg.append('path')
                .datum(mvtLine)
                .attr('d', lineSimMVT)
                .attr('fill', 'none')
                .attr('stroke', algorithmViewActive ? '#e67e22' : 'none')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');
            
            // Create arrays for plotting
            const simArray = similarities.map((sim, i) => ({ x: i, y: sim }));
            const softmaxArray = softmaxValues.map((softmax, i) => ({ x: i, y: softmax }));
            
            // Create lines
            const lineSim = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScaleSimilarity(d.y));
                
            const lineSoftmax = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScaleSoftmax(d.y));
            
            // Add line for similarity
            svg.append('path')
                .datum(simArray)
                .attr('d', lineSim)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 2);
                
            // Add line for softmax probabilities
            svg.append('path')
                .datum(softmaxArray)
                .attr('d', lineSoftmax)
                .attr('fill', 'none')
                .attr('stroke', algorithmViewActive ? '#9b59b6' : 'none')
                .attr('stroke-width', 2);
            
            // Add MVT threshold line
            svg.append('line')
                .attr('x1', margin.left)
                .attr('y1', yScaleSimilarity(mvtThreshold))
                .attr('x2', width - margin.right)
                .attr('y2', yScaleSimilarity(mvtThreshold))
                .attr('stroke', algorithmViewActive ? 'rgba(230, 126, 34, 0.7)' : 'none')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,5');
                
            svg.append('text')
                .attr('x', width - margin.right - 5)
                .attr('y', yScaleSimilarity(mvtThreshold) - 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', algorithmViewActive ? '#e67e22' : 'none')
                .text(`MVT Threshold: ${mvtThreshold.toFixed(2)}`);
            
            // Add exploitation/exploration decisions
            const phases = currentParticipant.phases;
            phases.forEach(phase => {
                if (phase.start >= similarities.length) return;
                
                const xStart = xScale(Math.max(0, phase.start));
                const xEnd = xScale(Math.min(similarities.length - 1, phase.end - 1));
                
                svg.append('rect')
                    .attr('x', xStart)
                    .attr('y', margin.top)
                    .attr('width', xEnd - xStart)
                    .attr('height', height - margin.top - margin.bottom)
                    .attr('fill', phase.type === 'Exploitation' ? '#2ecc7122' : '#e74c3c22')
                    .attr('stroke', 'none');
                    
                svg.append('text')
                    .attr('x', (xStart + xEnd) / 2)
                    .attr('y', margin.top + 15)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('fill', phase.type === 'Exploitation' ? '#27ae60' : '#c0392b')
                    .text(phase.type);
            });
            
            // Add dots for each similarity
            svg.selectAll('.simDot')
                .data(simArray)
                .enter()
                .append('circle')
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScaleSimilarity(d.y))
                .attr('r', 3)
                .attr('fill', '#3498db')
                .on('mouseover', (event, d) => {
                    tooltip.style('opacity', 1)
                        .html(`<strong>Similarity:</strong> ${d.y.toFixed(2)}<br>
                               <strong>Position:</strong> ${d.x + 1}<br>
                               <strong>Words:</strong> ${items[d.x]} → ${items[d.x + 1]}`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.style('opacity', 0);
                });
                
            // Add dots for each softmax value
            if (algorithmViewActive) {
                svg.selectAll('.softmaxDot')
                    .data(softmaxArray)
                    .enter()
                    .append('circle')
                    .attr('cx', d => xScale(d.x))
                    .attr('cy', d => yScaleSoftmax(d.y))
                    .attr('r', 3)
                    .attr('fill', '#9b59b6')
                    .on('mouseover', (event, d) => {
                        tooltip.style('opacity', 1)
                            .html(`<strong>Softmax Probability:</strong> ${d.y.toFixed(2)}<br>
                                   <strong>Position:</strong> ${d.x + 1}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', () => {
                        tooltip.style('opacity', 0);
                    });
            }
            
            // Add axes
            const xAxis = d3.axisBottom(xScale)
                .ticks(similarities.length > 10 ? 10 : similarities.length)
                .tickFormat(d => d + 1);
                
            const yAxisSim = d3.axisLeft(yScaleSimilarity)
                .ticks(5);
                
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .attr('class', 'axis')
                .call(xAxis);
                
            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .attr('class', 'axis')
                .call(yAxisSim);
                
            // If algorithm view is active, add right y-axis for softmax
            if (algorithmViewActive) {
                const yAxisSoftmax = d3.axisRight(yScaleSoftmax)
                    .ticks(5);
                    
                svg.append('g')
                    .attr('transform', `translate(${width - margin.right}, 0)`)
                    .attr('class', 'axis')
                    .call(yAxisSoftmax);
                    
                svg.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -height / 2)
                    .attr('y', width - 5)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .text('Softmax Probability');
                    
                // Add legend
                const legendY = height - margin.bottom + 40;
                
                svg.append('circle')
                    .attr('cx', margin.left + 10)
                    .attr('cy', legendY)
                    .attr('r', 4)
                    .attr('fill', '#3498db');
                    
                svg.append('text')
                    .attr('x', margin.left + 20)
                    .attr('y', legendY + 3)
                    .attr('font-size', '10px')
                    .text('Similarity');
                    
                svg.append('circle')
                    .attr('cx', margin.left + 90)
                    .attr('cy', legendY)
                    .attr('r', 4)
                    .attr('fill', '#9b59b6');
                    
                svg.append('text')
                    .attr('x', margin.left + 100)
                    .attr('y', legendY + 3)
                    .attr('font-size', '10px')
                    .text('Softmax');
                    
                svg.append('line')
                    .attr('x1', margin.left + 160)
                    .attr('y1', legendY)
                    .attr('x2', margin.left + 180)
                    .attr('y2', legendY)
                    .attr('stroke', '#e67e22')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                    
                svg.append('text')
                    .attr('x', margin.left + 190)
                    .attr('y', legendY + 3)
                    .attr('font-size', '10px')
                    .text('MVT Threshold');
            }
            
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .text('Word Pair Index');
                
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .text('Cosine Similarity');
        }

        // Helper function to calculate softmax
        function calculateSoftmax(values, temperature = 1.0) {
            // Adjust with temperature parameter
            const adjustedValues = values.map(v => v / temperature);
            
            const maxVal = Math.max(...adjustedValues);
            const expValues = adjustedValues.map(v => Math.exp(v - maxVal));
            const sumExp = expValues.reduce((acc, val) => acc + val, 0);
            
            return expValues.map(v => v / sumExp);
        }

        // Helper function to simulate MVT threshold
        function calculateMVT(similarities) {
            // For a simple implementation, we can use the mean similarity
            // In a real implementation, this would be based on the marginal value theorem
            const mean = d3.mean(similarities);
            
            // Add some randomness to simulate different thresholds per participant
            const variance = 0.1;
            return mean + (Math.random() * 2 - 1) * variance;
        }

        // Initialize on page load
        updateVisualization();
    </script>
</body>
</html>